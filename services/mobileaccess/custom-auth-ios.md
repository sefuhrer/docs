---

copyright:
  years: 2015, 2016

---

# Configuring {{site.data.keyword.amashort}} client SDK for iOS
{: #custom-ios}

Configure your iOS application that is using custom authentication to use the {{site.data.keyword.amashort}} client SDK and connect your application to {{site.data.keyword.Bluemix}}.

**Tip:** If you are developing your iOS app in Swift, consider using the {{site.data.keyword.amashort}} client Swift SDK. The instructions on this page apply to the {{site.data.keyword.amashort}} client Objective-C SDK. For instructions on using the Swift SDK, see [Configuring {{site.data.keyword.amashort}} client SDK for iOS (Swift SDK)](https://console.{DomainName}/docs/services/mobileaccess/custom-auth-ios-swift-sdk.html)

## Before you begin
{: #before-you-begin}
You must have a resource that is protected by an instance of the {{site.data.keyword.amashort}} service that is configured to use a custom identity provider.  Your mobile app also must be instrumented with the {{site.data.keyword.amashort}} client SDK.  For more information, see the following information:
 * [Getting started with {{site.data.keyword.amashort}}](https://console.{DomainName}/docs/services/mobileaccess/getting-started.html)
 * [Setting up the iOS Objective-C SDK](https://console.{DomainName}/docs/services/mobileaccess/getting-started-ios.html)
 * [Using a custom identity provider](https://console.{DomainName}/docs/services/mobileaccess/custom-auth.html)
 * [Creating a custom identity provider](https://console.{DomainName}/docs/services/mobileaccess/custom-auth-identity-provider.html)
 * [Configuring {{site.data.keyword.amashort}} for custom authentication](https://console.{DomainName}/docs/services/mobileaccess/custom-auth-config-mca.html)



## Installing the client SDK with CocoaPods
{: #custom-ios-sdk-cocoapods}
Use the CocoaPods dependency manager to install the {{site.data.keyword.amashort}} client SDK.

1. Open Terminal and navigate to the root directory of your iOS project.

1. Edit the `Podfile` and add the following line.

	```
	pod 'IMFCore'
	```

1. From the command line, run `pod install`.
CocoaPods installs added dependencies. The progress and which components were added are displayed.

**Important**: You must now open your project by using a xcworkspace file that was generated by CocoaPods. Usually the name is `{your-project-name}.xcworkspace`.

1. Run `open {your-project-name}.xcworkspace` from command line to open your iOS project workspace.



### Initializing the client SDK
{: #custom-ios-sdk-initialize}

Initialize the SDK by passing the application route (`applicationRoute`) and GUID (`applicationGUID`) parameters. A common, though not mandatory, place to put the initialization code is in the `application:didFinishLaunchingWithOptions` method of your application delegate

1. Get your application parameter values. Open your app in the {{site.data.keyword.Bluemix_notm}} dashboard. Click **Mobile Options** to see the values for **Route** (`applicationRoute`) and **App GUID** (`applicationGUID`).

1. Import the `IMFCore` framework in the class that you want to use client SDK.

	Objective-C:

	```Objective-C
	#import <IMFCore/IMFCore.h>
	```

	Swift:

	The {{site.data.keyword.amashort}} client SDK is implemented with Objective-C. You might need to add a bridging header to your Swift project to use the SDK.

	* Right-click your project in Xcode and select **New File...**
	* In the **iOS Source** category, pick **Header file**. Name the file `BridgingHeader.h`.
	* Add `#import <IMFCore/IMFCore.h>` to your bridging header.
	* Click your project in Xcode and select **Build Settings** tab.
	* Search for `Objective-C Bridging Header`.
	* Set the value to location of your `BridgingHeader.h` file, for example: `$(SRCROOT)/MyApp/BridgingHeader.h`
	* Verify that your bridging header is being picked up by Xcode by building your project.

1. Initialize the client SDK. Replace the applicationRoute and applicationGUID with the values for **Route** (`applicationRoute`) and **App GUID** (`applicationGUID`) that you obtained from **Mobile Options**.

	Objective-C:

	```Objective-C
	[[IMFClient sharedInstance]
			initializeWithBackendRoute:@"applicationRoute"
			backendGUID:@"applicationGUID"];
	```

	Swift:

	```Swift
	IMFClient.sharedInstance().initializeWithBackendRoute("applicationRoute",
	 							backendGUID: "applicationGUID")
	```


## IMFAuthenticationHandler delegate
{: #custom-ios-sdk-authhandler}


The {{site.data.keyword.amashort}} client SDK provides the `IMFAuthenticationHandler` interface to implement a custom authentication flow. The `IMFAuthenticationHandler` exposes three methods that are called on different phases of the authentication process.

```
- (void)authenticationContext:(id<IMFAuthenticationContext>)context
 						didReceiveAuthenticationChallenge:(NSDictionary*)challenge;
```

This method is called when a custom authentication challenge is received from {{site.data.keyword.amashort}} Service. The arguments include

* `IMFAuthenticationContext` protocol is provided by {{site.data.keyword.amashort}} client SDK so that developer can report back authentication challenge answers or failure during crendtials collection (e.g. user cancelled)
* `NSDictionary` containing a custom authentication challenge as returned by a Custom Identity Provider

By calling the `authenticationContext:didReceiveAuthenticationChallenge` method the {{site.data.keyword.amashort}} client SDK is delegating control to developer and putting itself into a waiting-for-credentials mode. It is developer responsibility to collect credentials and report them back to the {{site.data.keyword.amashort}} client SDK by using one of `IMFAuthenticationContext` protocol methods as will be described below.

```
- (void)authenticationContext:(id<IMFAuthenticationContext>)context
						didReceiveAuthenticationSuccess:(NSDictionary *)userInfo;
```

This method is called after a successful authentication. The arguments include IMFAuthenticationContext and an optional NSDictionary containing extended info about authentication success.

```
- (void)authenticationContext:(id<IMFAuthenticationContext>)context
						didReceiveAuthenticationFailure:(NSDictionary*)userInfo;
```

This method is called after authentication failure. The arguments include IMFAuthenticationContext and an optional NSDictionary containing extended info about authentication failure.

## IMFAuthenticationContext protocol
{: #custom-ios-sdk-authcontext}


`IMFAuthenticationContext` is supplied as an argument to the `authenticationContext:didReceiveAuthenticationChallenge` method of a custom `IMFAuthenticationHandler`. It is developer's responsibility to collect credentials and use `IMFAuthenticationContext` methods to either return credentials to {{site.data.keyword.amashort}} client SDK or report a failure. Use one of the below methods

```
-(void) submitAuthenticationChallengeAnswer:(NSDictionary*) answer;

-(void) submitAuthenticationFailure:(NSDictionary*) userInfo;
```

## Sample implementation of a custom IMFAuthenticationDelegate
{: #custom-ios-sdk-sample}


The IMFAuthenticationDelegate sample is designed to work with the custom identity provider sample. You can download the sample from the [Github repository](https://github.com/ibm-bluemix-mobile-services/bms-mca-custom-identity-provider-sample).

Objective-C:

``` Objective-C
CustomAuthenticationDelegate.h
-----------------------------------
#import <Foundation/Foundation.h>

@import IMFCore;
@interface CustomAuthenticationDelegate : NSObject <IMFAuthenticationDelegate>
@end


CustomAuthenticationDelegate.m
-----------------------------------
#import "CustomAuthenticationDelegate.h"

@implementation CustomAuthenticationDelegate

-(void)authenticationContext:(id<IMFAuthenticationContext>)context
					didReceiveAuthenticationChallenge:(NSDictionary *)challenge{

	NSLog(@"didReceiveAuthenticationChallenge :: %@", challenge);

	// In this sample the IMFAuthenticationDelegate immediately returns a hardcoded
	// set of credentials. In a real life scenario this is where developer would
	// show a login screen, collect credentials and invoke
	// [context submitAuthenticationChallengeAnswer:] API

	NSDictionary *challengeAnswer = [NSDictionary dictionaryWithObjectsAndKeys:
									 @"john.lennon", @"username",
									 @"12345", @"password", nil];

	[context submitAuthenticationChallengeAnswer:challengeAnswer];

	// In case there was a failure collecting credentials you need to report
	// it back to the IMFAuthenticationContext. Otherwise Mobile Client
	// Access client SDK will remain in a waiting-for-credentials state
	// forever
}

-(void)authenticationContext:(id<IMFAuthenticationContext>)context
					didReceiveAuthenticationSuccess:(NSDictionary *)userInfo{
	NSLog(@"didReceiveAuthenticationSuccess");


}

-(void)authenticationContext:(id<IMFAuthenticationContext>)context
					didReceiveAuthenticationFailure:(NSDictionary *)userInfo{
	NSLog(@"didReceiveAuthenticationFailure");

}

@end
```

Swift implementation:

```Swift
import Foundation

class CustomAuthenticationDelegate : NSObject, IMFAuthenticationDelegate{

	func authenticationContext(context: IMFAuthenticationContext!,
					didReceiveAuthenticationChallenge challenge: [NSObject : AnyObject]!) {

		NSLog("didReceiveAuthenticationChallenge :: %@", challenge)

		// In this sample the IMFAuthenticationDelegate immediately returns a hardcoded
		// set of credentials. In a real life scenario this is where developer would
		// show a login screen, collect credentials and invoke
		// context.submitAuthenticationChallengeAnswer() API

		let challengeAnswer: [String:String] = [
			"username":"john.lennon",
			"password":"12345"
		]

		context.submitAuthenticationChallengeAnswer(challengeAnswer)

		// In case there was a failure collecting credentials you need to report
		// it back to the IMFAuthenticationContext. Otherwise Mobile Client
		// Access client SDK will remain in a waiting-for-credentials state
		// forever
	}


	func authenticationContext(context: IMFAuthenticationContext!,
					didReceiveAuthenticationSuccess userInfo: [NSObject : AnyObject]!) {
		NSLog("didReceiveAuthenticationSuccess")
	}

	func authenticationContext(context: IMFAuthenticationContext!,
					didReceiveAuthenticationFailure userInfo: [NSObject : AnyObject]!) {
		NSLog("didReceiveAuthenticationFailure")
	}
}
```

## Registering custom IMFAuthenticationDelegate

After you create a custom IMFAuthenticationDelegate, register with `IMFClient`. Call the following code in your application before you send any requests to your protected resources. Use realmName that you specified in the {{site.data.keyword.amashort}} dashboard.

Objective-C applications:

```Objective-C
[[IMFClient sharedInstance]
				registerAuthenticationDelegate:[CustomAuthenticationDelegate new]
										forRealm:realmName];
```

Swift applications:
```Swift
IMFClient.sharedInstance().registerAuthenticationDelegate(CustomAuthenticationDelegate(),
									forRealm: realmName)
```




## Testing the authentication
{: #custom-ios-testing}
After you initialize the client SDK and register a custom `IMFAuthenticationDelegate`, you can start making requests to your mobile backend.

### Before you begin
{: #custom-ios-testing-before}
 You must have an application that was created with the {{site.data.keyword.mobilefirstbp}} boilerplate and have a resource that is protected by {{site.data.keyword.amashort}} at the `/protected` endpoint.

1. Send a request to protected endpoint of your mobile backend in your browser by opening `{applicationRoute}/protected`, for example `http://my-mobile-backend.mybluemix.net/protected`.
  The `/protected` endpoint of a mobile backend that is created with the {{site.data.keyword.mobilefirstbp}} boilerplate is protected with {{site.data.keyword.amashort}}. The endpoint can  be accessed by only mobile applications that are instrumented with the {{site.data.keyword.amashort}} client SDK. As a result, an `Unauthorized` message displays in your browser.
1. Use your iOS application to make request to the same endpoint. Add the following code after you initialize `BMSClient` and register your custom `IMFAuthenticationDelegate`:

	Objective-C:

	```Objective-C
	NSString *requestPath = [NSString stringWithFormat:@"%@/protected",
								[[IMFClient sharedInstance] backendRoute]];

	IMFResourceRequest *request =  [IMFResourceRequest requestWithPath:requestPath
																method:@"GET"];

	[request sendWithCompletionHandler:^(IMFResponse *response, NSError *error) {
		if (error){
			NSLog(@"Error :: %@", [error description]);
		} else {
			NSLog(@"Response :: %@", [response responseText]);
			NSLog(@"%@", [[IMFAuthorizationManager sharedInstance] userIdentity]);
		}
	}];
	```

	Swift:

	```Swift
	let requestPath = IMFClient.sharedInstance().backendRoute + "/protected"

	let request = IMFResourceRequest(path: requestPath, method: "GET");
	request.sendWithCompletionHandler { (response, error) -> Void in
		if (nil != error){
			NSLog("Error :: %@", error.description)
		} else {
			NSLog("Response :: %@", response.responseText)
			NSLog("%@", IMFAuthorizationManager.sharedInstance().userIdentity)
		}
	};

	```
1. 	When your requests succeeds, you see the following output in the Xcode console:

	![image](images/ios-custom-login-success.png)

	You can also add logout functionality by adding the following code:

	Objective C:

	```Objective-C
	[[IMFAuthorizationManager sharedInstance] logout : callBack]
	```

	Swift:

	```Swift
	IMFAuthorizationManager.sharedInstance().logout(callBack)
	```

 If you call this code after a user is logged in, the user is logged out. When the user tries to log in again, they must answer the challenge received from the server again.

 Passing `callBack` to the logout function is optional. You can also pass `nil`.
